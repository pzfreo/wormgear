// generator-worker.js
// Web Worker for wormgear geometry generation
// Runs Pyodide + build123d + OCP in background thread to keep UI responsive

let pyodide = null;
let isLoading = false;
let loadComplete = false;

// Listen for messages from main thread
self.onmessage = async (e) => {
    const { type, data } = e.data;

    if (type === 'INIT') {
        await initializePyodide();
    } else if (type === 'GENERATE') {
        await generateGeometry(data);
    }
};

async function initializePyodide() {
    if (loadComplete) {
        self.postMessage({ type: 'INIT_COMPLETE' });
        return;
    }

    if (isLoading) {
        self.postMessage({ type: 'INIT_ERROR', error: 'Already loading' });
        return;
    }

    isLoading = true;

    try {
        self.postMessage({ type: 'LOG', message: 'Loading Pyodide...' });

        // Load Pyodide
        self.importScripts('https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js');

        pyodide = await loadPyodide({
            indexURL: "https://cdn.jsdelivr.net/pyodide/v0.29.0/full/",
            stdout: (text) => {
                if (text.trim()) self.postMessage({ type: 'LOG', message: `[py] ${text}` });
            },
            stderr: (text) => {
                if (text.trim()) self.postMessage({ type: 'LOG', message: `[py:err] ${text}` });
            }
        });

        self.postMessage({ type: 'LOG', message: '‚úì Pyodide loaded' });

        // Install micropip and pydantic (pydantic must use loadPackage, not micropip, due to pydantic-core)
        self.postMessage({ type: 'LOG', message: 'Installing micropip and pydantic...' });
        await pyodide.loadPackage(['micropip', 'pydantic']);
        const micropip = pyodide.pyimport('micropip');
        self.postMessage({ type: 'LOG', message: '‚úì micropip and pydantic ready' });

        // Install build123d and OCP
        self.postMessage({ type: 'LOG', message: 'üì¶ Installing build123d and OCP (2-5 minutes)...' });
        self.postMessage({ type: 'LOG', message: '‚è≥ Large download - please be patient...' });

        const result = await pyodide.runPythonAsync(`
import micropip

print("Starting package installation...")
print("Setting index URLs...")
micropip.set_index_urls(["https://yeicor.github.io/OCP.wasm", "https://pypi.org/simple"])
print("Index URLs set")

print("Installing lib3mf...")
await micropip.install("lib3mf")
print("‚úì lib3mf installed")

print("Installing ssl...")
await micropip.install("ssl")
print("‚úì ssl installed")

print("Installing ocp_vscode from Jojain's fork...")
await micropip.install("https://raw.githubusercontent.com/Jojain/vscode-ocp-cad-viewer/no_pyperclip/ocp_vscode-2.9.0-py3-none-any.whl")
print("‚úì ocp_vscode installed")

# Mock package for build123d<0.10.0 compatibility
micropip.add_mock_package("py-lib3mf", "2.4.1", modules={"py_lib3mf": '''from lib3mf import *'''})
print("‚úì Mock package added")

print("Installing build123d and sqlite3...")
await micropip.install(["build123d", "sqlite3"])
print("‚úì Installation completed")

# Test imports
print("Testing imports...")
try:
    import build123d
    print(f"‚úì build123d imported (version: {getattr(build123d, '__version__', 'unknown')})")
    success = True
except ImportError as e:
    print(f"‚úó build123d import failed: {e}")
    success = False

"SUCCESS" if success else "FAILED"
        `);

        if (result === 'SUCCESS') {
            self.postMessage({ type: 'LOG', message: '‚úì All packages installed!' });

            // Load wormgear package
            await loadWormGearPackage();

            loadComplete = true;
            self.postMessage({ type: 'INIT_COMPLETE' });
            self.postMessage({ type: 'LOG', message: 'Generator ready!' });
        } else {
            throw new Error('Package installation failed');
        }

    } catch (error) {
        // Better error handling - ensure we always get a string
        const errorMessage = error?.message || error?.toString() || String(error) || 'Unknown initialization error';
        const errorStack = error?.stack || '';

        console.error('[Worker] Init error:', error);

        self.postMessage({
            type: 'INIT_ERROR',
            error: errorMessage,
            stack: errorStack
        });
    } finally {
        isLoading = false;
    }
}

async function loadWormGearPackage() {
    self.postMessage({ type: 'LOG', message: 'Loading wormgear package...' });

    // Fetch manifest of Python files (generated by build.sh)
    const manifestResp = await fetch('wormgear-manifest.json');
    if (!manifestResp.ok) {
        throw new Error('Failed to fetch wormgear-manifest.json: ' + manifestResp.status);
    }
    const filePaths = await manifestResp.json();

    // Create all necessary directories in Pyodide's virtual filesystem
    const dirs = new Set();
    for (const p of filePaths) {
        const parts = p.split('/');
        for (let i = 1; i < parts.length; i++) {
            dirs.add('/home/pyodide/' + parts.slice(0, i).join('/'));
        }
    }
    await pyodide.runPythonAsync(`
import os, sys
for d in ${JSON.stringify([...dirs].sort())}:
    os.makedirs(d, exist_ok=True)
if '/home/pyodide' not in sys.path:
    sys.path.insert(0, '/home/pyodide')
    `);

    // Load all Python files into Pyodide
    for (const filePath of filePaths) {
        const response = await fetch(filePath);
        if (!response.ok) {
            throw new Error('Failed to fetch ' + filePath + ': ' + response.status);
        }
        const content = await response.text();
        pyodide.FS.writeFile('/home/pyodide/' + filePath, content);
    }

    self.postMessage({ type: 'LOG', message: `‚úì Loaded ${filePaths.length} package files` });

    // Test import
    await pyodide.runPythonAsync(`
import wormgear
from wormgear.core import WormGeometry, WheelGeometry
from wormgear.io import WormParams, WheelParams, AssemblyParams
print(f"‚úì wormgear package loaded (version {wormgear.__version__})")
    `);

    self.postMessage({ type: 'LOG', message: '‚úì wormgear package ready' });
}

async function generateGeometry(data) {
    if (!loadComplete) {
        self.postMessage({
            type: 'GENERATE_ERROR',
            error: 'Pyodide not loaded. Initialize first.'
        });
        return;
    }

    try {
        const {
            designData,
            wormLength,
            wheelWidth,
            virtualHobbing,
            hobbingSteps,
            generateType,
            generationMethod = 'sweep'
        } = data;

        self.postMessage({ type: 'LOG', message: '‚è≥ Starting geometry generation...' });

        // Create JavaScript function accessible to Python
        self.postProgressUpdate = (message, percent) => {
            console.log('[Worker] Progress update:', message, percent);
            self.postMessage({
                type: 'PROGRESS',
                message: message,
                percent: percent
            });
        };

        // Create progress callback that posts messages to main thread
        const progressCallback = pyodide.runPython(`
def progress_callback(message, percent):
    """Progress callback - sends updates to main thread via worker"""
    import js
    print(f"[Python] Progress: {message} ({percent}%)")
    js.postProgressUpdate(message, percent)

progress_callback
        `);

        // Set Python globals
        pyodide.globals.set('design_json_str', JSON.stringify(designData));
        pyodide.globals.set('worm_length', wormLength);
        pyodide.globals.set('wheel_width_val', wheelWidth || null);
        pyodide.globals.set('virtual_hobbing_val', virtualHobbing);
        pyodide.globals.set('hobbing_steps_val', hobbingSteps);
        pyodide.globals.set('generate_type', generateType);
        pyodide.globals.set('generation_method_val', generationMethod);
        pyodide.globals.set('progress_callback_fn', progressCallback);

        // Run generation
        const result = await pyodide.runPythonAsync(`
import json
import base64
import logging

# Configure logging - INFO for wormgear modules, suppress verbose build123d internals
logging.basicConfig(level=logging.INFO, format='[%(name)s] %(levelname)s: %(message)s')
for logger_name in ['wormgear.core.worm', 'wormgear.core.wheel', 'wormgear.core.globoid_worm', 'wormgear.core.virtual_hobbing', 'wormgear.core.features']:
    logging.getLogger(logger_name).setLevel(logging.INFO)
# Suppress build123d's verbose internal logging (BuildSketch, WorkplaneList, etc.)
logging.getLogger('build123d').setLevel(logging.WARNING)

from wormgear.core import WormGeometry, WheelGeometry, GloboidWormGeometry, VirtualHobbingWheelGeometry, BoreFeature, KeywayFeature, DDCutFeature, calculate_default_bore
from wormgear.io import WormParams, WheelParams, AssemblyParams

print("üìã Parsing parameters...")
# Parse design JSON
design_data = json.loads(design_json_str)

# Create parameter objects
worm_params = WormParams(**design_data['worm'])
wheel_params = WheelParams(**design_data['wheel'])
assembly_params = AssemblyParams(**design_data['assembly'])

# Handle None wheel_width
try:
    wheel_width = float(wheel_width_val) if wheel_width_val else None
except (TypeError, ValueError):
    wheel_width = None
print(f"Wheel width: {wheel_width if wheel_width else 'auto-calculated'}")
print(f"Worm length (from JS): {worm_length}")

# Sections per turn: only relevant for globoid loft method (hardcoded to 36)
# Cylindrical worms use sweep by default, which ignores sections_per_turn
sections_per_turn = 36

# Parse features section for bores and keyways
features = design_data.get('features', {}) or {}  # Handle None case

# Worm features
worm_bore = None
worm_keyway = None
worm_ddcut = None
worm_bore_diameter = None

if 'worm' in features:
    worm_feat = features['worm']
    if 'bore_diameter_mm' in worm_feat and worm_feat['bore_diameter_mm'] is not None:
        worm_bore_diameter = worm_feat['bore_diameter_mm']
        print(f"Worm bore: {worm_bore_diameter} mm")

    # Create bore feature if diameter was determined
    if worm_bore_diameter is not None:
        worm_bore = BoreFeature(diameter=worm_bore_diameter)

        # Add anti-rotation feature if specified (keyway and ddcut are mutually exclusive)
        if 'anti_rotation' in worm_feat:
            anti_rot = worm_feat['anti_rotation']

            if anti_rot == 'DIN6885':
                if worm_bore_diameter >= 6.0:
                    print(f"Worm keyway: DIN 6885")
                    worm_keyway = KeywayFeature()
                else:
                    print(f"Worm keyway: skipped (bore {worm_bore_diameter}mm < 6mm minimum for DIN 6885)")

            elif anti_rot == 'ddcut':
                # Calculate depth as ~10% of bore diameter (standard practice for small shafts)
                dd_depth = round(worm_bore_diameter * 0.1, 1)
                print(f"Worm DD-cut: double-D flat anti-rotation (depth={dd_depth}mm)")
                worm_ddcut = DDCutFeature(depth=dd_depth)

            elif anti_rot not in ['none', '']:
                print(f"Worm anti-rotation: unknown type '{anti_rot}', skipping")

# Wheel features
wheel_bore = None
wheel_keyway = None
wheel_ddcut = None
wheel_bore_diameter = None

if 'wheel' in features:
    wheel_feat = features['wheel']
    if 'bore_diameter_mm' in wheel_feat and wheel_feat['bore_diameter_mm'] is not None:
        wheel_bore_diameter = wheel_feat['bore_diameter_mm']
        print(f"Wheel bore: {wheel_bore_diameter} mm")

    # Create bore feature if diameter was determined
    if wheel_bore_diameter is not None:
        wheel_bore = BoreFeature(diameter=wheel_bore_diameter)

        # Add anti-rotation feature if specified (keyway and ddcut are mutually exclusive)
        if 'anti_rotation' in wheel_feat:
            anti_rot = wheel_feat['anti_rotation']

            if anti_rot == 'DIN6885':
                if wheel_bore_diameter >= 6.0:
                    print(f"Wheel keyway: DIN 6885")
                    wheel_keyway = KeywayFeature()
                else:
                    print(f"Wheel keyway: skipped (bore {wheel_bore_diameter}mm < 6mm minimum for DIN 6885)")

            elif anti_rot == 'ddcut':
                # Calculate depth as ~10% of bore diameter (standard practice for small shafts)
                dd_depth = round(wheel_bore_diameter * 0.1, 1)
                print(f"Wheel DD-cut: double-D flat anti-rotation (depth={dd_depth}mm)")
                wheel_ddcut = DDCutFeature(depth=dd_depth)

            elif anti_rot not in ['none', '']:
                print(f"Wheel anti-rotation: unknown type '{anti_rot}', skipping")

print("‚úì Parameters parsed")
print("")

worm = None  # Will hold worm geometry if generated

# Check if globoid - either by type field or presence of throat curvature radius
# Note: worm_params.type is a WormType enum, so compare .value or check throat_curvature_radius_mm
worm_type_value = getattr(worm_params.type, 'value', worm_params.type) if hasattr(worm_params, 'type') and worm_params.type else None
is_globoid = (worm_type_value == 'globoid') or \
             (hasattr(worm_params, 'throat_curvature_radius_mm') and worm_params.throat_curvature_radius_mm is not None)
print(f"Worm type: {worm_type_value}, is_globoid: {is_globoid}")

# Generate worm if requested
if generate_type in ['worm', 'both']:
    print("üî© Generating worm gear...")
    try:
        print("  Creating worm geometry object...")
        if is_globoid:
            print("  Using globoid (hourglass) worm geometry...")
            worm_geo = GloboidWormGeometry(
                params=worm_params,
                assembly_params=assembly_params,
                wheel_pitch_diameter=wheel_params.pitch_diameter_mm,
                length=worm_length,
                sections_per_turn=sections_per_turn,
                bore=worm_bore,
                keyway=worm_keyway,
                ddcut=worm_ddcut
            )
        else:
            worm_geo = WormGeometry(
                params=worm_params,
                assembly_params=assembly_params,
                length=worm_length,
                bore=worm_bore,
                keyway=worm_keyway,
                ddcut=worm_ddcut,
                generation_method=generation_method_val
            )
        print("  Building 3D model...")
        worm = worm_geo.build()
        print(f"‚úì Worm built (volume: {worm.volume:.2f} mm¬≥)")
    except Exception as e:
        print(f"‚úó Worm generation failed: {e}")
        import traceback
        traceback.print_exc()

    print("")

# Generate wheel if requested
wheel = None
if generate_type in ['wheel', 'both']:
    print("‚öôÔ∏è  Generating wheel gear...")
    try:
        print("  Creating wheel geometry object...")

        # Use VirtualHobbingWheelGeometry if virtual_hobbing enabled, otherwise regular WheelGeometry
        if virtual_hobbing_val:
            # Virtual hobbing supports progress callbacks
            print(f"  Using virtual hobbing with {hobbing_steps_val} steps...")

            # Pass the actual worm geometry as hob ONLY for globoid (important for accuracy)
            # For cylindrical, let VirtualHobbingWheelGeometry create a simpler hob internally
            hob_geo = worm if (generate_type == 'both' and is_globoid) else None
            hob_type = "globoid" if is_globoid else "cylindrical"
            print(f"  Using {hob_type} hob geometry")

            wheel_geo = VirtualHobbingWheelGeometry(
                params=wheel_params,
                worm_params=worm_params,
                assembly_params=assembly_params,
                face_width=wheel_width,
                hobbing_steps=hobbing_steps_val,
                progress_callback=progress_callback_fn,
                bore=wheel_bore,
                keyway=wheel_keyway,
                ddcut=wheel_ddcut,
                hob_geometry=hob_geo
            )
        else:
            # Regular helical wheel (no progress callbacks needed - it's fast)
            wheel_geo = WheelGeometry(
                params=wheel_params,
                worm_params=worm_params,
                assembly_params=assembly_params,
                face_width=wheel_width,
                bore=wheel_bore,
                keyway=wheel_keyway,
                ddcut=wheel_ddcut
            )
        print("  Building 3D model (this is the slowest step)...")
        wheel = wheel_geo.build()
        print(f"‚úì Wheel built (volume: {wheel.volume:.2f} mm¬≥)")
    except Exception as e:
        print(f"‚úó Wheel generation failed: {e}")
        import traceback
        traceback.print_exc()

    print("")

# Construct WormGearDesign for generate_package
from wormgear.io.loaders import WormGearDesign
design_obj = WormGearDesign(
    worm=worm_params,
    wheel=wheel_params,
    assembly=assembly_params,
)

# Export all files using shared package module
from wormgear.io.package import generate_package
print("üì¶ Exporting files (STEP, 3MF, STL, assembly)...")
files = generate_package(
    design=design_obj,
    worm=worm,
    wheel=wheel,
    virtual_hobbing=virtual_hobbing_val,
    log=print,
)

# Base64 encode for JS transport
worm_b64 = base64.b64encode(files.worm_step).decode() if files.worm_step else None
wheel_b64 = base64.b64encode(files.wheel_step).decode() if files.wheel_step else None
worm_3mf_b64 = base64.b64encode(files.worm_3mf).decode() if files.worm_3mf else None
wheel_3mf_b64 = base64.b64encode(files.wheel_3mf).decode() if files.wheel_3mf else None
worm_stl_b64 = base64.b64encode(files.worm_stl).decode() if files.worm_stl else None
wheel_stl_b64 = base64.b64encode(files.wheel_stl).decode() if files.wheel_stl else None
assembly_3mf_b64 = base64.b64encode(files.assembly_3mf).decode() if files.assembly_3mf else None

# Report results
if generate_type == 'worm' and worm_b64:
    print("‚úÖ Worm generated successfully!")
elif generate_type == 'wheel' and wheel_b64:
    print("‚úÖ Wheel generated successfully!")
elif generate_type == 'both':
    if worm_b64 and wheel_b64:
        print("‚úÖ Both parts generated successfully!")
    elif worm_b64:
        print("‚ö†Ô∏è  Only worm generated (wheel failed)")
    elif wheel_b64:
        print("‚ö†Ô∏è  Only wheel generated (worm failed)")
    else:
        print("‚ùå Both parts failed to generate")

# Return results (markdown will be generated on main thread using calculator Pyodide)
{
    'worm': worm_b64,
    'wheel': wheel_b64,
    'worm_3mf': worm_3mf_b64,
    'wheel_3mf': wheel_3mf_b64,
    'worm_stl': worm_stl_b64,
    'wheel_stl': wheel_stl_b64,
    'assembly_3mf': assembly_3mf_b64,
    'mesh_rotation_deg': files.mesh_rotation_deg,
    'success': (generate_type == 'worm' and worm_b64 is not None) or
               (generate_type == 'wheel' and wheel_b64 is not None) or
               (generate_type == 'both' and worm_b64 is not None and wheel_b64 is not None)
}
        `);

        // Send results back to main thread
        const success = result.get('success');
        const wormB64 = result.get('worm');
        const wheelB64 = result.get('wheel');
        const worm3mfB64 = result.get('worm_3mf');
        const wheel3mfB64 = result.get('wheel_3mf');
        const wormStlB64 = result.get('worm_stl');
        const wheelStlB64 = result.get('wheel_stl');
        const assembly3mfB64 = result.get('assembly_3mf');
        const meshRotationDeg = result.get('mesh_rotation_deg') || 0;

        self.postMessage({
            type: 'GENERATE_COMPLETE',
            success: success,
            worm: wormB64,
            wheel: wheelB64,
            worm_3mf: worm3mfB64,
            wheel_3mf: wheel3mfB64,
            worm_stl: wormStlB64,
            wheel_stl: wheelStlB64,
            assembly_3mf: assembly3mfB64,
            mesh_rotation_deg: meshRotationDeg
        });

    } catch (error) {
        // Better error handling - ensure we always get a string
        const errorMessage = error?.message || error?.toString() || String(error) || 'Unknown error';
        const errorStack = error?.stack || '';

        console.error('[Worker] Generate error:', error);

        self.postMessage({
            type: 'GENERATE_ERROR',
            error: errorMessage,
            stack: errorStack
        });
    }
}

/**
 * 3D Preview Viewer Module
 *
 * Renders animated worm+wheel assembly using Three.js.
 * Loads STL data from base64 (already generated by the worker),
 * positions parts using the same transforms as position_for_mesh()
 * from mesh_alignment.py, and animates at the correct gear ratio.
 */

import * as THREE from 'three';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';

let renderer = null;
let scene = null;
let camera = null;
let controls = null;
let wheelMesh = null;
let wormMesh = null;
let wormPivot = null;
let designInfo = null;
let animationId = null;
let playing = true;
let speedMultiplier = 1.0;
let initialized = false;

const BASE_SPEED = 0.02; // radians per frame for worm

/**
 * Decode base64 string to ArrayBuffer for STLLoader.parse()
 */
function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}

/**
 * Initialize the 3D viewer.
 * Call once, then use loadMeshes() to load data.
 */
export function initViewer(canvas) {
    if (initialized) return;

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x1a1a2e);
    renderer.setPixelRatio(window.devicePixelRatio);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);

    controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    scene.add(new THREE.AmbientLight(0x404060, 1.5));
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(50, 80, 50);
    scene.add(dirLight1);
    const dirLight2 = new THREE.DirectionalLight(0x8888cc, 1);
    dirLight2.position.set(-30, -20, -40);
    scene.add(dirLight2);

    // Grid on XY plane (build123d is Z-up)
    const grid = new THREE.GridHelper(100, 20, 0x444466, 0x333355);
    grid.rotation.x = Math.PI / 2;
    scene.add(grid);

    initialized = true;
    resizeViewer(canvas);
}

/**
 * Load STL meshes from base64 data and position them.
 *
 * @param {string} wormStlBase64 - Base64-encoded binary STL for worm
 * @param {string} wheelStlBase64 - Base64-encoded binary STL for wheel
 * @param {object} info - Design info: { centre_distance_mm, ratio, num_starts, num_teeth, hand, mesh_rotation_deg }
 */
export function loadMeshes(wormStlBase64, wheelStlBase64, info) {
    if (!initialized) return;

    designInfo = info;

    // Clear previous meshes
    if (wheelMesh) { scene.remove(wheelMesh); wheelMesh.geometry.dispose(); wheelMesh = null; }
    if (wormPivot) { scene.remove(wormPivot); wormMesh.geometry.dispose(); wormMesh = null; wormPivot = null; }

    const stlLoader = new STLLoader();
    const cd = info.centre_distance_mm;

    // Parse STL from base64
    const wormGeom = stlLoader.parse(base64ToArrayBuffer(wormStlBase64));
    const wheelGeom = stlLoader.parse(base64ToArrayBuffer(wheelStlBase64));
    wormGeom.computeVertexNormals();
    wheelGeom.computeVertexNormals();

    // Wheel: at origin, axis along Z, initial rotation for tooth engagement
    // Same as position_for_mesh(): wheel.rotate(Axis.Z, optimal_rotation_deg)
    const wheelMat = new THREE.MeshStandardMaterial({
        color: 0xc8a832, metalness: 0.6, roughness: 0.3, side: THREE.DoubleSide,
    });
    wheelMesh = new THREE.Mesh(wheelGeom, wheelMat);
    wheelMesh.rotation.z = THREE.MathUtils.degToRad(info.mesh_rotation_deg || 0);
    scene.add(wheelMesh);

    // Worm: replicate position_for_mesh() from mesh_alignment.py:
    //   1. Rotate -90 deg around Y (axis Z -> X)
    //   2. Translate to (0, centre_distance, 0)
    // Pivot group handles world positioning; worm rotates around local Z.
    const wormMat = new THREE.MeshStandardMaterial({
        color: 0x8888aa, metalness: 0.7, roughness: 0.25, side: THREE.DoubleSide,
    });
    wormMesh = new THREE.Mesh(wormGeom, wormMat);

    wormPivot = new THREE.Group();
    wormPivot.rotation.y = THREE.MathUtils.degToRad(-90);
    wormPivot.position.set(0, cd, 0);
    wormPivot.add(wormMesh);
    scene.add(wormPivot);

    // Position camera to view assembly
    controls.target.set(0, cd / 2, 0);
    camera.position.set(80, cd / 2 + 30, 60);
    controls.update();

    // Start animation
    playing = true;
    if (!animationId) animate();
}

/**
 * Animation loop.
 */
function animate() {
    animationId = requestAnimationFrame(animate);

    if (playing && wormMesh && wheelMesh && designInfo) {
        const wormSpeed = BASE_SPEED * speedMultiplier;

        // Worm rotates around local Z (world X due to pivot)
        wormMesh.rotation.z += wormSpeed;

        // Wheel rotates around Z at gear ratio speed
        const direction = designInfo.hand === 'right' ? -1 : 1;
        wheelMesh.rotation.z += direction * wormSpeed * designInfo.num_starts / designInfo.num_teeth;
    }

    if (controls) controls.update();
    if (renderer && scene && camera) renderer.render(scene, camera);
}

/**
 * Resize renderer to match canvas container.
 */
export function resizeViewer(canvas) {
    if (!renderer || !camera) return;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (width === 0 || height === 0) return;
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

/**
 * Pause animation (e.g., when tab is hidden).
 */
export function pauseAnimation() {
    playing = false;
}

/**
 * Resume animation (e.g., when tab is shown).
 */
export function resumeAnimation() {
    playing = true;
    if (!animationId) animate();
}

/**
 * Set animation speed multiplier.
 */
export function setSpeed(speed) {
    speedMultiplier = speed;
}

/**
 * Toggle play/pause state.
 * @returns {boolean} New playing state
 */
export function togglePlayPause() {
    playing = !playing;
    return playing;
}

/**
 * Check if viewer has been initialized with mesh data.
 */
export function isLoaded() {
    return initialized && wheelMesh !== null;
}

/**
 * Export positioned assembly as GLB (binary glTF).
 *
 * Builds a standalone scene from STL base64 data, positions the parts
 * using the same transforms as position_for_mesh(), and exports to GLB.
 * Does not require the viewer to be initialized.
 *
 * @param {string} wormStlBase64 - Base64-encoded binary STL for worm
 * @param {string} wheelStlBase64 - Base64-encoded binary STL for wheel
 * @param {object} info - { centre_distance_mm, mesh_rotation_deg }
 * @returns {Promise<ArrayBuffer>} GLB binary data
 */
export async function exportAssemblyGLB(wormStlBase64, wheelStlBase64, info) {
    const stlLoader = new STLLoader();
    const cd = info.centre_distance_mm;

    // Parse STL meshes
    const wormGeom = stlLoader.parse(base64ToArrayBuffer(wormStlBase64));
    const wheelGeom = stlLoader.parse(base64ToArrayBuffer(wheelStlBase64));
    wormGeom.computeVertexNormals();
    wheelGeom.computeVertexNormals();

    // Build a static assembly scene
    const exportScene = new THREE.Scene();

    // Wheel at origin with mesh rotation
    const wheelMat = new THREE.MeshStandardMaterial({
        color: 0xc8a832, metalness: 0.6, roughness: 0.3,
    });
    const wheelObj = new THREE.Mesh(wheelGeom, wheelMat);
    wheelObj.name = 'wheel';
    wheelObj.rotation.z = THREE.MathUtils.degToRad(info.mesh_rotation_deg || 0);
    exportScene.add(wheelObj);

    // Worm: rotate -90 deg around Y, translate to (0, CD, 0)
    const wormMat = new THREE.MeshStandardMaterial({
        color: 0x8888aa, metalness: 0.7, roughness: 0.25,
    });
    const wormObj = new THREE.Mesh(wormGeom, wormMat);
    wormObj.name = 'worm';
    const pivot = new THREE.Group();
    pivot.name = 'worm_pivot';
    pivot.rotation.y = THREE.MathUtils.degToRad(-90);
    pivot.position.set(0, cd, 0);
    pivot.add(wormObj);
    exportScene.add(pivot);

    // Export as GLB
    const exporter = new GLTFExporter();
    return exporter.parseAsync(exportScene, { binary: true });
}

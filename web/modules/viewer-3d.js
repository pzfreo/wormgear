/**
 * 3D Preview Viewer Module
 *
 * Renders animated worm+wheel assembly using Three.js.
 * Loads 3MF data from base64 (already generated by the worker),
 * positions parts using the same transforms as position_for_mesh()
 * from mesh_alignment.py, and animates at the correct gear ratio.
 *
 * Uses 3MF (via ThreeMFLoader) because build123d's export_stl()
 * drops thread geometry on compound worm shapes. The Mesher-based
 * 3MF export correctly captures all faces.
 */

import * as THREE from 'three';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { ThreeMFLoader } from 'three/addons/loaders/3MFLoader.js';

let renderer = null;
let scene = null;
let camera = null;
let controls = null;
let wheelMesh = null;
let wormMesh = null;
let wormPivot = null;
let designInfo = null;
let animationId = null;
let playing = true;
let speedMultiplier = 1.0;
let initialized = false;

const BASE_SPEED = 0.02; // radians per frame for worm

/**
 * Decode base64 string to ArrayBuffer.
 */
function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}

/**
 * Extract the first Mesh geometry from a 3MF-parsed Group.
 * ThreeMFLoader.parse() returns a Group containing child Meshes.
 */
function extractGeometry(group) {
    let geom = null;
    group.traverse((child) => {
        if (!geom && child.isMesh && child.geometry) {
            geom = child.geometry;
        }
    });
    return geom;
}

/**
 * Initialize the 3D viewer.
 * Call once, then use loadMeshes() to load data.
 */
export function initViewer(canvas) {
    if (initialized) return;

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x1a1a2e);
    renderer.setPixelRatio(window.devicePixelRatio);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);

    controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    scene.add(new THREE.AmbientLight(0x404060, 1.5));
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(50, 80, 50);
    scene.add(dirLight1);
    const dirLight2 = new THREE.DirectionalLight(0x8888cc, 1);
    dirLight2.position.set(-30, -20, -40);
    scene.add(dirLight2);

    // Grid on XY plane (build123d is Z-up)
    const grid = new THREE.GridHelper(100, 20, 0x444466, 0x333355);
    grid.rotation.x = Math.PI / 2;
    scene.add(grid);

    initialized = true;
    resizeViewer(canvas);
}

/**
 * Parse a 3MF base64 string into a BufferGeometry.
 */
function parse3MF(base64) {
    const loader = new ThreeMFLoader();
    const group = loader.parse(base64ToArrayBuffer(base64));
    const geom = extractGeometry(group);
    if (!geom) throw new Error('No mesh found in 3MF data');
    geom.computeVertexNormals();
    return geom;
}

/**
 * Load meshes from base64 data and position them.
 * Accepts 3MF data (preferred, from Mesher) or STL data (fallback).
 *
 * @param {object} meshData - { worm_3mf, wheel_3mf, worm_stl, wheel_stl }
 * @param {object} info - Design info: { centre_distance_mm, ratio, num_starts, num_teeth, hand, mesh_rotation_deg }
 */
export function loadMeshes(meshData, info) {
    if (!initialized) return;

    designInfo = info;

    // Clear previous meshes
    if (wheelMesh) { scene.remove(wheelMesh); wheelMesh.geometry.dispose(); wheelMesh = null; }
    if (wormPivot) { scene.remove(wormPivot); wormMesh.geometry.dispose(); wormMesh = null; wormPivot = null; }

    const cd = info.centre_distance_mm;

    // Parse geometry - prefer 3MF (correct), fall back to STL
    let wormGeom, wheelGeom;
    if (meshData.worm_3mf && meshData.wheel_3mf) {
        console.log('[Viewer] Using 3MF mesh data');
        wormGeom = parse3MF(meshData.worm_3mf);
        wheelGeom = parse3MF(meshData.wheel_3mf);
    } else if (meshData.worm_stl && meshData.wheel_stl) {
        console.log('[Viewer] Falling back to STL mesh data');
        const stlLoader = new STLLoader();
        wormGeom = stlLoader.parse(base64ToArrayBuffer(meshData.worm_stl));
        wheelGeom = stlLoader.parse(base64ToArrayBuffer(meshData.wheel_stl));
        wormGeom.computeVertexNormals();
        wheelGeom.computeVertexNormals();
    } else {
        console.error('[Viewer] No mesh data available');
        return;
    }

    // Wheel: at origin, axis along Z, initial rotation for tooth engagement
    const wheelMat = new THREE.MeshStandardMaterial({
        color: 0xc8a832, metalness: 0.6, roughness: 0.3, side: THREE.DoubleSide,
    });
    wheelMesh = new THREE.Mesh(wheelGeom, wheelMat);
    wheelMesh.rotation.z = THREE.MathUtils.degToRad(info.mesh_rotation_deg || 0);
    scene.add(wheelMesh);

    // Worm: replicate position_for_mesh() from mesh_alignment.py:
    //   1. Rotate -90 deg around Y (axis Z -> X)
    //   2. Translate to (0, centre_distance, 0)
    const wormMat = new THREE.MeshStandardMaterial({
        color: 0x8888aa, metalness: 0.7, roughness: 0.25, side: THREE.DoubleSide,
    });
    wormMesh = new THREE.Mesh(wormGeom, wormMat);

    wormPivot = new THREE.Group();
    wormPivot.rotation.y = THREE.MathUtils.degToRad(-90);
    wormPivot.position.set(0, cd, 0);
    wormPivot.add(wormMesh);
    scene.add(wormPivot);

    // Position camera to view assembly
    controls.target.set(0, cd / 2, 0);
    camera.position.set(80, cd / 2 + 30, 60);
    controls.update();

    // Start animation
    playing = true;
    if (!animationId) animate();
}

/**
 * Animation loop.
 */
function animate() {
    animationId = requestAnimationFrame(animate);

    if (playing && wormMesh && wheelMesh && designInfo) {
        const wormSpeed = BASE_SPEED * speedMultiplier;

        // Worm rotates around local Z (world X due to pivot)
        wormMesh.rotation.z += wormSpeed;

        // Wheel rotates around Z at gear ratio speed
        const direction = designInfo.hand === 'right' ? -1 : 1;
        wheelMesh.rotation.z += direction * wormSpeed * designInfo.num_starts / designInfo.num_teeth;
    }

    if (controls) controls.update();
    if (renderer && scene && camera) renderer.render(scene, camera);
}

/**
 * Resize renderer to match canvas container.
 */
export function resizeViewer(canvas) {
    if (!renderer || !camera) return;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (width === 0 || height === 0) return;
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

/**
 * Pause animation (e.g., when tab is hidden).
 */
export function pauseAnimation() {
    playing = false;
}

/**
 * Resume animation (e.g., when tab is shown).
 */
export function resumeAnimation() {
    playing = true;
    if (!animationId) animate();
}

/**
 * Set animation speed multiplier.
 */
export function setSpeed(speed) {
    speedMultiplier = speed;
}

/**
 * Toggle play/pause state.
 * @returns {boolean} New playing state
 */
export function togglePlayPause() {
    playing = !playing;
    return playing;
}

/**
 * Check if viewer has been initialized with mesh data.
 */
export function isLoaded() {
    return initialized && wheelMesh !== null;
}

/**
 * Export positioned assembly as GLB (binary glTF).
 *
 * Builds a standalone scene from mesh data, positions the parts
 * using the same transforms as position_for_mesh(), and exports to GLB.
 * Does not require the viewer to be initialized.
 *
 * @param {object} meshData - { worm_3mf, wheel_3mf, worm_stl, wheel_stl }
 * @param {object} info - { centre_distance_mm, mesh_rotation_deg }
 * @returns {Promise<ArrayBuffer>} GLB binary data
 */
export async function exportAssemblyGLB(meshData, info) {
    const cd = info.centre_distance_mm;

    // Parse geometry - prefer 3MF
    let wormGeom, wheelGeom;
    if (meshData.worm_3mf && meshData.wheel_3mf) {
        wormGeom = parse3MF(meshData.worm_3mf);
        wheelGeom = parse3MF(meshData.wheel_3mf);
    } else {
        // STL fallback (may be missing thread detail)
        const stlLoader = new STLLoader();
        wormGeom = stlLoader.parse(base64ToArrayBuffer(meshData.worm_stl));
        wheelGeom = stlLoader.parse(base64ToArrayBuffer(meshData.wheel_stl));
        wormGeom.computeVertexNormals();
        wheelGeom.computeVertexNormals();
    }

    // Bake transforms directly into geometry vertices so the GLB has
    // flat structure (no nested groups that some viewers mishandle).

    // Wheel: rotate around Z for mesh engagement
    if (info.mesh_rotation_deg) {
        wheelGeom.rotateZ(THREE.MathUtils.degToRad(info.mesh_rotation_deg));
    }

    // Worm: rotate -90° around Y (axis Z→X), then translate to (0, CD, 0)
    const wormMatrix = new THREE.Matrix4()
        .makeTranslation(0, cd, 0)
        .multiply(new THREE.Matrix4().makeRotationY(-Math.PI / 2));
    wormGeom.applyMatrix4(wormMatrix);

    // Build a flat scene with positioned geometry
    const exportScene = new THREE.Scene();

    const wheelMat = new THREE.MeshStandardMaterial({
        color: 0xc8a832, metalness: 0.6, roughness: 0.3,
    });
    const wheelObj = new THREE.Mesh(wheelGeom, wheelMat);
    wheelObj.name = 'wheel';
    exportScene.add(wheelObj);

    const wormMat = new THREE.MeshStandardMaterial({
        color: 0x8888aa, metalness: 0.7, roughness: 0.25,
    });
    const wormObj = new THREE.Mesh(wormGeom, wormMat);
    wormObj.name = 'worm';
    exportScene.add(wormObj);

    // Export as GLB
    const exporter = new GLTFExporter();
    return exporter.parseAsync(exportScene, { binary: true });
}

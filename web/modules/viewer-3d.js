/**
 * 3D Preview Viewer Module
 *
 * Renders animated worm+wheel assembly using Three.js.
 * Parses 3MF data manually (JSZip + DOMParser) because ThreeMFLoader
 * can't reliably handle build123d's 3MF output. Falls back to STL
 * when 3MF is unavailable.
 *
 * For the assembly view, prefers the pre-positioned assembly.3mf
 * (generated by Python's position_for_mesh() + Mesher) which contains
 * correct geometry for both parts including compound worm shapes.
 */

import * as THREE from 'three';
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
import { toCreasedNormals } from 'three/addons/utils/BufferGeometryUtils.js';

let renderer = null;
let scene = null;
let camera = null;
let controls = null;
let wheelMesh = null;
let wormMesh = null;
let wormPivot = null;
let designInfo = null;
let animationId = null;
let playing = true;
let speedMultiplier = 1.0;
let initialized = false;

const BASE_SPEED = 0.02; // radians per frame for worm

/**
 * Decode base64 string to ArrayBuffer.
 */
function base64ToArrayBuffer(base64) {
    const binary = atob(base64);
    const buffer = new ArrayBuffer(binary.length);
    const view = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        view[i] = binary.charCodeAt(i);
    }
    return buffer;
}

/**
 * Parse a 3MF base64 string into a BufferGeometry by manually
 * extracting vertex/triangle data from the XML inside the ZIP.
 *
 * 3MF is a ZIP containing XML. The mesh data lives in
 * 3D/3dmodel.model under the 3MF namespace.
 *
 * @param {string} base64 - Base64-encoded 3MF file
 * @returns {Promise<THREE.BufferGeometry>}
 */
async function parse3MFManual(base64) {
    const arrayBuffer = base64ToArrayBuffer(base64);
    const zip = await JSZip.loadAsync(arrayBuffer);

    // Find the model file (usually 3D/3dmodel.model)
    let modelXml = null;
    for (const filename of Object.keys(zip.files)) {
        if (filename.toLowerCase().endsWith('.model')) {
            modelXml = await zip.files[filename].async('text');
            break;
        }
    }
    if (!modelXml) throw new Error('No .model file found in 3MF archive');

    const parser = new DOMParser();
    const doc = parser.parseFromString(modelXml, 'application/xml');

    const ns = 'http://schemas.microsoft.com/3dmanufacturing/core/2015/02';

    // Collect ALL vertices and triangles from ALL mesh objects in the file.
    // A 3MF file can contain multiple <object> elements (e.g. assembly.3mf
    // has wheel + worm as separate objects). We merge them into one geometry.
    const meshElements = doc.getElementsByTagNameNS(ns, 'mesh');
    if (meshElements.length === 0) throw new Error('No <mesh> elements found in 3MF model');

    const allPositions = [];
    const allIndices = [];
    let vertexOffset = 0;

    for (const meshEl of meshElements) {
        const vertexNodes = meshEl.getElementsByTagNameNS(ns, 'vertex');
        const triangleNodes = meshEl.getElementsByTagNameNS(ns, 'triangle');

        // Extract vertices
        for (const v of vertexNodes) {
            allPositions.push(
                parseFloat(v.getAttribute('x')),
                parseFloat(v.getAttribute('y')),
                parseFloat(v.getAttribute('z'))
            );
        }

        // Extract triangles (offset indices by cumulative vertex count)
        for (const t of triangleNodes) {
            allIndices.push(
                parseInt(t.getAttribute('v1')) + vertexOffset,
                parseInt(t.getAttribute('v2')) + vertexOffset,
                parseInt(t.getAttribute('v3')) + vertexOffset
            );
        }

        vertexOffset += vertexNodes.length;
    }

    // Build Three.js BufferGeometry
    const positions = new Float32Array(allPositions);
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geom.setIndex(allIndices);

    // Use crease-angle normals so sharp edges (thread walls, groove edges)
    // stay crisp instead of being smoothed into pillowy shapes.
    // 30° threshold: edges sharper than this get hard normals.
    return toCreasedNormals(geom, Math.PI / 6);
}

/**
 * Parse an STL base64 string into a BufferGeometry.
 */
function parseSTL(base64) {
    const stlLoader = new STLLoader();
    const geom = stlLoader.parse(base64ToArrayBuffer(base64));
    return toCreasedNormals(geom, Math.PI / 6);
}

/**
 * Initialize the 3D viewer.
 * Call once, then use loadMeshes() to load data.
 */
export function initViewer(canvas) {
    if (initialized) return;

    renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setClearColor(0x1a1a2e);
    renderer.setPixelRatio(window.devicePixelRatio);

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);

    controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;

    // Lighting
    scene.add(new THREE.AmbientLight(0x404060, 1.5));
    const dirLight1 = new THREE.DirectionalLight(0xffffff, 2);
    dirLight1.position.set(50, 80, 50);
    scene.add(dirLight1);
    const dirLight2 = new THREE.DirectionalLight(0x8888cc, 1);
    dirLight2.position.set(-30, -20, -40);
    scene.add(dirLight2);

    // Grid on XY plane (build123d is Z-up)
    const grid = new THREE.GridHelper(100, 20, 0x444466, 0x333355);
    grid.rotation.x = Math.PI / 2;
    scene.add(grid);

    initialized = true;
    resizeViewer(canvas);
}

/**
 * Load meshes from base64 data and position them.
 * Accepts 3MF data (preferred, from Mesher) or STL data (fallback).
 *
 * @param {object} meshData - { worm_3mf, wheel_3mf, worm_stl, wheel_stl }
 * @param {object} info - Design info: { centre_distance_mm, ratio, num_starts, num_teeth, hand, mesh_rotation_deg }
 */
export async function loadMeshes(meshData, info) {
    if (!initialized) return;

    designInfo = info;

    // Clear previous meshes
    if (wheelMesh) { scene.remove(wheelMesh); wheelMesh.geometry.dispose(); wheelMesh = null; }
    if (wormPivot) { scene.remove(wormPivot); wormMesh.geometry.dispose(); wormMesh = null; wormPivot = null; }

    const cd = info.centre_distance_mm;

    // Parse geometry - prefer 3MF (correct), fall back to STL
    let wormGeom, wheelGeom;
    if (meshData.worm_3mf && meshData.wheel_3mf) {
        console.log('[Viewer] Using 3MF mesh data');
        try {
            wormGeom = await parse3MFManual(meshData.worm_3mf);
            wheelGeom = await parse3MFManual(meshData.wheel_3mf);
        } catch (err) {
            console.warn('[Viewer] 3MF parse failed, falling back to STL:', err);
            if (meshData.worm_stl && meshData.wheel_stl) {
                wormGeom = parseSTL(meshData.worm_stl);
                wheelGeom = parseSTL(meshData.wheel_stl);
            } else {
                console.error('[Viewer] No fallback STL data available');
                return;
            }
        }
    } else if (meshData.worm_stl && meshData.wheel_stl) {
        console.log('[Viewer] Falling back to STL mesh data');
        wormGeom = parseSTL(meshData.worm_stl);
        wheelGeom = parseSTL(meshData.wheel_stl);
    } else {
        console.error('[Viewer] No mesh data available');
        return;
    }

    // Wheel: at origin, axis along Z, initial rotation for tooth engagement
    const wheelMat = new THREE.MeshStandardMaterial({
        color: 0xc8a832, metalness: 0.6, roughness: 0.3, side: THREE.DoubleSide,
    });
    wheelMesh = new THREE.Mesh(wheelGeom, wheelMat);
    wheelMesh.rotation.z = THREE.MathUtils.degToRad(info.mesh_rotation_deg || 0);
    scene.add(wheelMesh);

    // Worm: replicate position_for_mesh() from mesh_alignment.py:
    //   1. Rotate -90 deg around Y (axis Z -> X)
    //   2. Translate to (0, centre_distance, 0)
    const wormMat = new THREE.MeshStandardMaterial({
        color: 0x8888aa, metalness: 0.7, roughness: 0.25, side: THREE.DoubleSide,
    });
    wormMesh = new THREE.Mesh(wormGeom, wormMat);

    wormPivot = new THREE.Group();
    wormPivot.rotation.y = THREE.MathUtils.degToRad(-90);
    wormPivot.position.set(0, cd, 0);
    wormPivot.add(wormMesh);
    scene.add(wormPivot);

    // Position camera to view assembly
    controls.target.set(0, cd / 2, 0);
    camera.position.set(80, cd / 2 + 30, 60);
    controls.update();

    // Start animation
    playing = true;
    if (!animationId) animate();
}

/**
 * Animation loop.
 */
function animate() {
    animationId = requestAnimationFrame(animate);

    if (playing && wormMesh && wheelMesh && designInfo) {
        const wormSpeed = BASE_SPEED * speedMultiplier;

        // Worm rotates around local Z (world X due to pivot)
        wormMesh.rotation.z += wormSpeed;

        // Wheel rotates around Z at gear ratio speed
        const direction = designInfo.hand === 'right' ? -1 : 1;
        wheelMesh.rotation.z += direction * wormSpeed * designInfo.num_starts / designInfo.num_teeth;
    }

    if (controls) controls.update();
    if (renderer && scene && camera) renderer.render(scene, camera);
}

/**
 * Resize renderer to match canvas container.
 */
export function resizeViewer(canvas) {
    if (!renderer || !camera) return;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    if (width === 0 || height === 0) return;
    renderer.setSize(width, height, false);
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
}

/**
 * Pause animation (e.g., when tab is hidden).
 */
export function pauseAnimation() {
    playing = false;
}

/**
 * Resume animation (e.g., when tab is shown).
 */
export function resumeAnimation() {
    playing = true;
    if (!animationId) animate();
}

/**
 * Set animation speed multiplier.
 */
export function setSpeed(speed) {
    speedMultiplier = speed;
}

/**
 * Toggle play/pause state.
 * @returns {boolean} New playing state
 */
export function togglePlayPause() {
    playing = !playing;
    return playing;
}

/**
 * Check if viewer has been initialized with mesh data.
 */
export function isLoaded() {
    return initialized && wheelMesh !== null;
}

/**
 * Export positioned assembly as GLB (binary glTF).
 *
 * Prefers assembly_3mf (pre-positioned by Python) which contains correct
 * geometry for both parts. Falls back to individual 3MF/STL files with
 * JS-side positioning if assembly_3mf is not available.
 *
 * @param {object} meshData - { assembly_3mf, worm_3mf, wheel_3mf, worm_stl, wheel_stl }
 * @param {object} info - { centre_distance_mm, mesh_rotation_deg }
 * @returns {Promise<ArrayBuffer>} GLB binary data
 */
export async function exportAssemblyGLB(meshData, info) {
    const cd = info.centre_distance_mm;
    const exportScene = new THREE.Scene();

    if (meshData.assembly_3mf) {
        // Assembly 3MF has both parts already positioned by Python
        console.log('[GLB Export] Using pre-positioned assembly.3mf');
        const assemblyGeom = await parse3MFManual(meshData.assembly_3mf);

        const mat = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa, metalness: 0.6, roughness: 0.3,
        });
        const assemblyObj = new THREE.Mesh(assemblyGeom, mat);
        assemblyObj.name = 'assembly';
        exportScene.add(assemblyObj);
    } else {
        // Fallback: parse individual parts and position in JS
        console.log('[GLB Export] Positioning individual parts');
        let wormGeom, wheelGeom;
        if (meshData.worm_3mf && meshData.wheel_3mf) {
            wormGeom = await parse3MFManual(meshData.worm_3mf);
            wheelGeom = await parse3MFManual(meshData.wheel_3mf);
        } else {
            wormGeom = parseSTL(meshData.worm_stl);
            wheelGeom = parseSTL(meshData.wheel_stl);
        }

        // Wheel: rotate around Z for mesh engagement
        if (info.mesh_rotation_deg) {
            wheelGeom.rotateZ(THREE.MathUtils.degToRad(info.mesh_rotation_deg));
        }

        // Worm: rotate -90° around Y (axis Z→X), then translate to (0, CD, 0)
        const wormMatrix = new THREE.Matrix4()
            .makeTranslation(0, cd, 0)
            .multiply(new THREE.Matrix4().makeRotationY(-Math.PI / 2));
        wormGeom.applyMatrix4(wormMatrix);

        const wheelMat = new THREE.MeshStandardMaterial({
            color: 0xc8a832, metalness: 0.6, roughness: 0.3,
        });
        const wheelObj = new THREE.Mesh(wheelGeom, wheelMat);
        wheelObj.name = 'wheel';
        exportScene.add(wheelObj);

        const wormMat = new THREE.MeshStandardMaterial({
            color: 0x8888aa, metalness: 0.7, roughness: 0.25,
        });
        const wormObj = new THREE.Mesh(wormGeom, wormMat);
        wormObj.name = 'worm';
        exportScene.add(wormObj);
    }

    // Export as GLB
    const exporter = new GLTFExporter();
    return exporter.parseAsync(exportScene, { binary: true });
}
